# Input section
input {

# Host Syslog
  file {
    path => ["/data/host/log/syslog", "/data/host/log/auth.log"]
    codec => plain
    type => "Syslog"
  }
}

# Filter Section
filter {

# Syslog
  if [type] == "Syslog" {
      grok {
        match => {
          "message" => ["%{SYSLOGPAMSESSION}", "%{CRONLOG}", "%{SYSLOGLINE}"]
        }
        overwrite => "message"
      }
      date {
        match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
        remove_field => ["timestamp"]
      }
      date {
        match => ["timestamp8601", "ISO8601"]
        remove_field => ["timestamp8601"]
      }
      grok {
        match => { "message" => "Connection closed by %{IP:src_ip}" }
        add_tag => [ "ssh_connection_closed" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Received disconnect from %{IP:src_ip}" }
        add_tag => [ "ssh_connection_disconnect" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Failed password for invalid user %{USERNAME:username} from %{IP:src_ip} port %{BASE10NUM:port} ssh2" }
        add_tag => [ "ssh_failed_password" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Did not receive identification string from %{IP:src_ip}" }
        add_tag => [ "ssh_no_id" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "User %{USERNAME:username} from %{IP:src_ip} not allowed because not listed in AllowUsers" }
        add_tag => [ "ssh_user_not_allowed" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "authentication failure; logname=%{USERNAME:logname} uid=%{BASE10NUM:uid} euid=%{BASE10NUM:euid} tty=%{TTY:tty} ruser=%{USERNAME:ruser} rhost=(?:%{HOSTNAME:remote_host}|\s*) user=%{USERNAME:user}"}
        add_tag => [ "ssh_auth_failure" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "pam_unix\(sshd:auth\): authentication failure; logname= uid=0 euid=0 tty=%{NOTSPACE:tty} ruser= rhost=(?:%{HOSTNAME:remote_host}|\s*)  user=%{USERNAME:user}"}
        add_tag => [ "ssh_auth_failure" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Failed password for %{USERNAME:username} from %{IP:src_ip} port %{BASE10NUM:port} ssh2"}
        add_tag => [ "ssh_failed_password" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Accepted password for %{USERNAME:username} from %{IP:src_ip} port %{BASE10NUM:port} ssh2"}
        add_tag => [ "ssh_accepted_password" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Accepted publickey for %{USERNAME:username} from %{IP:src_ip} port %{BASE10NUM:port} ssh2"}
        add_tag => [ "ssh_accepted_pubkey" ]
        tag_on_failure => []
      }
      grok {
        match => { "message" => "Accepted keyboard-interactive/pam for %{USERNAME:username} from %{IP:src_ip} port %{BASE10NUM:port} ssh2"}
        add_tag => [ "ssh_accepted_interactive" ]
        tag_on_failure => []
      }
  }

# Add geo coordinates / ASN info
  if [src_ip]  {
    geoip {
      source => "src_ip"
      target => "geoip"
      database => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-filter-geoip-2.0.5/vendor/GeoLiteCity-2013-01-18.dat"
      add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
      add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
    }
    mutate {
      convert => [ "[geoip][coordinates]", "float" ]
    }
    geoip {
      source => "src_ip"
      target => "geoip"
      database => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-filter-geoip-2.0.5/vendor/GeoIPASNum-2014-02-12.dat"
      add_field => [ "[geoip][full]", "%{[geoip][number]} %{[geoip][asn]}" ]
    }
  }
}

# Output section
output {
  elasticsearch {
    hosts => ["localhost:9200"]
  }
  #stdout {
  #  codec => json
  #}
}
